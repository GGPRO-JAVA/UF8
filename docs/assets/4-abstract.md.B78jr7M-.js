import{_ as a,c as t,o as i,a0 as e}from"./chunks/framework.CpfCQ-4g.js";const k=JSON.parse('{"title":"4. Classes abstractes","description":"","frontmatter":{},"headers":[],"relativePath":"4-abstract.md","filePath":"4-abstract.md"}'),n={name:"4-abstract.md"};function l(r,s,p,c,o,h){return i(),t("div",null,s[0]||(s[0]=[e(`<h1 id="_4-classes-abstractes" tabindex="-1">4. Classes abstractes <a class="header-anchor" href="#_4-classes-abstractes" aria-label="Permalink to &quot;4. Classes abstractes&quot;">​</a></h1><p>Una classe abstracta és <strong>una classe que declara l&#39;existència d&#39;alguns mètodes però no la seua implementació</strong> (és a dir, conté la capçalera del mètode però no el seu codi). Els mètodes sense implementar són mètodes abstractes.</p><p>Una classe abstracta pot contindre tant mètodes abstractes (sense implementar) com no abstractes (implementats). Però almenys un ha de ser abstracte. Per a declarar una classe o mètode com a abstracte s&#39;utilitza el modificador <strong>abstract</strong>.</p><div class="warning custom-block github-alert"><p class="custom-block-title"><strong>ATENCIÓ!:</strong></p><p>Una classe abstracta <strong>no es pot instanciar</strong>, però <strong>sí es pot heretar</strong>. Les subclasses hauran d&#39;implementar obligatòriament el codi dels mètodes abstractes (llevat que també es declaren com a abstractes).</p></div><p>Les <strong>classes abstractes</strong> <u>són útils quan necessitem definir una forma generalitzada de classe que serà compartida per les subclasses, deixant part del codi en la classe abstracta (mètodes “normals”) i delegant una altra part en les subclasses (mètodes abstractes)</u>.</p><div class="warning custom-block github-alert"><p class="custom-block-title"><strong>ATENCIÓ!:</strong></p><p>No poden declarar-se constructors o mètodes estàtics abstractes.</p></div><p>La finalitat principal d&#39;una classe abstracta és crear una classe heretada a partir d&#39;ella. Per això, en la pràctica és obligatori aplicar herència (si no, la classe abstracta no serveix per a res). El cas contrari és una classe final, que no pot heretar-se com ja hem vist. Per tant <strong>una classe no pot ser abstract i final al mateix temps</strong>.</p><p>Per exemple, aquesta classe abstracta Principal ten dos mètodes: un concret i un altre abstracte.</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Principal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Mètode concret amb implementació</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> metodeConcret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Mètode abstracte sense implementació</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> metodeAbstracte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Aquesta subclasse hereta de Principal tots dos mètodes, però està obligada a implementar el codi del mètode abstracte.</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Secundària</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Principal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Implementació concreta</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> metodeAbstracte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,11)]))}const g=a(n,[["render",l]]);export{k as __pageData,g as default};
